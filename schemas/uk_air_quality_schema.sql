-- UK Air Quality schema (bigint IDs + external *_ref fields)
-- External identifiers that arrive as text (even if numeric) use *_ref.
-- Internal joins always use bigint *_id columns.
-- Safe to rerun; uses IF NOT EXISTS where appropriate.

-- Ensure needed extensions
-- PostGIS remains in public on Supabase hosted Postgres.
create extension if not exists postgis;
create extension if not exists pgcrypto;

-- Connectors (external data sources)
create table if not exists connectors (
  id bigint generated by default as identity primary key,
  connector_code text not null,
  label text not null,
  display_name text,
  service_url text,
  station_display_name_template text,
  overwrite_station_name boolean default true,
  poll_enabled boolean default true,
  poll_interval_minutes int default 60,
  poll_window_hours int default 6,
  poll_timeseries_batch_size int,
  stations_bbox_supported boolean default true,
  timeseries_station_filter_supported boolean default true,
  last_polled_at timestamptz,
  last_run_start timestamptz,
  last_run_end timestamptz,
  last_run_status text,
  last_run_message text,
  created_at timestamptz default now()
);

create unique index if not exists connectors_connector_code_uidx on connectors(connector_code);

-- Default flags for known connectors (applies on insert; update existing rows if present).
create or replace function connectors_apply_known_defaults()
returns trigger
set search_path = public, pg_catalog
as $$
begin
  new.display_name = coalesce(new.display_name, new.label);
  if new.service_url = 'https://uk-air.defra.gov.uk/sos-ukair/api/v1'
     or new.label = 'UK-AIR-SOS' then
    new.stations_bbox_supported = false;
    new.timeseries_station_filter_supported = false;
  end if;
  if new.connector_code = 'sensorcommunity'
     or new.label = 'Sensor.Community' then
    new.overwrite_station_name = false;
  end if;
  return new;
end;
$$ language plpgsql;

drop trigger if exists connectors_apply_known_defaults on connectors;
create trigger connectors_apply_known_defaults
before insert on connectors
for each row execute function connectors_apply_known_defaults();

-- Categories
create table if not exists categories (
  id bigint generated by default as identity primary key,
  category_ref text not null,
  label text not null,
  connector_id bigint not null references connectors(id) on delete cascade
);

create unique index if not exists categories_connector_ref_uidx on categories(connector_id, category_ref);

-- Phenomena (pollutants)
create table if not exists phenomena (
  id bigint generated by default as identity primary key,
  label text not null,
  eionet_uri text,
  notation text,
  pollutant_label text,
  connector_id bigint not null references connectors(id) on delete cascade
);

create unique index if not exists phenomena_service_eionet_uidx
  on phenomena(connector_id, eionet_uri);

-- Offerings
create table if not exists offerings (
  id bigint generated by default as identity primary key,
  offering_ref text not null,
  label text not null,
  service_ref text not null,
  connector_id bigint not null references connectors(id) on delete cascade
);

create unique index if not exists offerings_connector_ref_uidx
  on offerings(connector_id, service_ref, offering_ref);

-- Features of interest (sites/areas)
create table if not exists features (
  id bigint generated by default as identity primary key,
  feature_ref text not null,
  label text not null,
  geometry geography(Point, 4326),
  service_ref text not null,
  connector_id bigint not null references connectors(id) on delete cascade
);

create unique index if not exists features_connector_ref_uidx
  on features(connector_id, service_ref, feature_ref);

-- Procedures (sensors/methods)
create table if not exists procedures (
  id bigint generated by default as identity primary key,
  procedure_ref text not null,
  label text not null,
  raw_formats text[],
  service_ref text not null,
  connector_id bigint not null references connectors(id) on delete cascade
);

create unique index if not exists procedures_connector_ref_uidx
  on procedures(connector_id, service_ref, procedure_ref);

-- Stations
create table if not exists stations (
  id bigint generated by default as identity primary key,
  station_ref text not null,
  service_ref text not null,
  label text not null,
  station_name text,
  station_type text,
  station_exposure text,
  region text,
  la_code text,
  la_version text,
  pcon_code text,
  pcon_version text,
  geometry geography(Point, 4326),
  connector_id bigint not null references connectors(id) on delete cascade,
  category_id bigint references categories(id),
  first_seen_at timestamptz default now(),
  last_seen_at timestamptz,
  removed_at timestamptz,
  created_at timestamptz default now()
);

create table if not exists station_metadata (
  station_id bigint primary key references stations(id) on delete cascade,
  attributes jsonb not null default '{}'::jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists station_network_memberships (
  station_id bigint not null references stations(id) on delete cascade,
  network_code text not null,
  network_label text,
  is_primary boolean default false,
  created_at timestamptz default now(),
  primary key (station_id, network_code)
);

create table if not exists uk_aq_networks (
  id bigint generated by default as identity primary key,
  network_code text not null,
  display_name text not null,
  connector_code text not null references connectors(connector_code),
  is_active boolean default true,
  created_at timestamptz default now()
);

create unique index if not exists uk_aq_networks_network_code_uidx
  on uk_aq_networks(network_code);

create index if not exists uk_aq_networks_connector_code_idx
  on uk_aq_networks(connector_code);

-- Optional FK (validate after seeding uk_aq_networks).
do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'station_network_memberships_network_code_fkey'
      and conrelid = 'station_network_memberships'::regclass
  ) then
    execute
      'alter table if exists station_network_memberships '
      'add constraint station_network_memberships_network_code_fkey '
      'foreign key (network_code) references uk_aq_networks(network_code) '
      'not valid';
  end if;
end $$;

create table if not exists uk_air_sos_networks (
  network_ref text primary key,
  network_code text,
  network_display_name text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create unique index if not exists uk_air_sos_networks_network_code_uidx
  on uk_air_sos_networks(network_code)
  where network_code is not null;

create table if not exists uk_air_sos_network_pollutants (
  network_ref text not null references uk_air_sos_networks(network_ref) on delete cascade,
  match_type text not null default 'contains',
  match_value text not null,
  created_at timestamptz default now(),
  primary key (network_ref, match_type, match_value)
);

create table if not exists uk_air_sos_site_register (
  id bigint generated by default as identity primary key,
  uk_air_id text not null,
  eu_site_id text,
  emep_site_id text,
  site_name text,
  environment_type text,
  zone text,
  start_date date,
  end_date date,
  latitude double precision,
  longitude double precision,
  northing double precision,
  easting double precision,
  altitude_m double precision,
  networks text[] not null default '{}'::text[],
  aurn_pollutants_measured text,
  site_description text,
  source_url text,
  source_file text,
  snapshot_at timestamptz not null default now(),
  raw_payload jsonb not null default '{}'::jsonb,
  created_at timestamptz default now()
);

create index if not exists uk_air_sos_site_register_uk_air_id_idx
  on uk_air_sos_site_register(uk_air_id);
create index if not exists uk_air_sos_site_register_snapshot_idx
  on uk_air_sos_site_register(snapshot_at);
create index if not exists uk_air_sos_site_register_networks_gin_idx
  on uk_air_sos_site_register using gin (networks);
create unique index if not exists uk_air_sos_site_register_snapshot_uidx
  on uk_air_sos_site_register(uk_air_id, snapshot_at);

create table if not exists laqn_site_register (
  id bigint generated by default as identity primary key,
  site_ref text not null,
  label text,
  station_name text,
  station_type text,
  station_exposure text,
  local_authority text,
  network_label text,
  networks text[] not null default '{}'::text[],
  latitude double precision,
  longitude double precision,
  lat_offset double precision,
  lon_offset double precision,
  site_url text,
  first_seen_at timestamptz,
  last_seen_at timestamptz,
  removed_at timestamptz,
  source_url text,
  source_file text,
  snapshot_at timestamptz not null default now(),
  raw_payload jsonb not null default '{}'::jsonb,
  created_at timestamptz default now()
);

create index if not exists laqn_site_register_site_ref_idx
  on laqn_site_register(site_ref);
create index if not exists laqn_site_register_snapshot_idx
  on laqn_site_register(snapshot_at);
create index if not exists laqn_site_register_networks_gin_idx
  on laqn_site_register using gin (networks);
create unique index if not exists laqn_site_register_snapshot_uidx
  on laqn_site_register(site_ref, snapshot_at);

create table if not exists uk_air_sos_station_refs (
  station_id bigint primary key references stations(id) on delete cascade,
  uk_air_id text not null,
  match_method text,
  match_distance_m double precision,
  source_snapshot_at timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create index if not exists uk_air_sos_station_refs_uk_air_id_idx
  on uk_air_sos_station_refs(uk_air_id);
create index if not exists uk_air_sos_station_refs_snapshot_idx
  on uk_air_sos_station_refs(source_snapshot_at);

create table if not exists breathelondon_timeseries_checkpoints (
  station_id bigint not null references stations(id) on delete cascade,
  species text not null,
  timeseries_id bigint references timeseries(id) on delete set null,
  last_observed_at timestamptz,
  last_fetch_at timestamptz,
  last_error text,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  primary key (station_id, species)
);

create index if not exists breathelondon_timeseries_checkpoints_last_obs_idx
  on breathelondon_timeseries_checkpoints(last_observed_at);

create table if not exists erg_laqn_station_checkpoints (
  station_id bigint primary key references stations(id) on delete cascade,
  last_polled_at timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create index if not exists erg_laqn_station_checkpoints_last_polled_idx
  on erg_laqn_station_checkpoints(last_polled_at);

create table if not exists uk_air_sos_timeseries_checkpoints (
  timeseries_id bigint primary key references timeseries(id) on delete cascade,
  last_polled_at timestamptz not null,
  updated_at timestamptz not null default now()
);

create index if not exists uk_air_sos_timeseries_checkpoints_last_polled_at_idx
  on uk_air_sos_timeseries_checkpoints(last_polled_at);

create or replace function uk_air_sos_select_timeseries_ids(
  batch_limit integer default 200
)
returns bigint[]
language plpgsql
set search_path = public, pg_catalog
as $$
declare
  v_connector_id bigint;
  series_ids bigint[];
begin
  select id into v_connector_id
  from connectors
  where connector_code = 'uk_air_sos'
  limit 1;

  if v_connector_id is null then
    return null;
  end if;

  with candidates as (
    select ts.id
    from timeseries ts
    left join uk_air_sos_timeseries_checkpoints chk on chk.timeseries_id = ts.id
    where ts.connector_id = v_connector_id
    order by (chk.last_polled_at is not null),
      chk.last_polled_at,
      ts.id
    limit batch_limit
  )
  select array_agg(id) into series_ids
  from candidates;

  return series_ids;
end;
$$;

create unique index if not exists stations_connector_ref_uidx
  on stations(connector_id, service_ref, station_ref);
create index if not exists stations_geom_idx on stations using gist (geometry);
create index if not exists stations_geom_cast_idx on stations using gist ((geometry::geometry));
create index if not exists stations_la_code_idx on stations(la_code);
create index if not exists stations_la_version_idx on stations(la_version);
create index if not exists stations_pcon_code_idx on stations(pcon_code);
create index if not exists stations_pcon_version_idx on stations(pcon_version);
create index if not exists stations_pcon_code_null_idx
  on stations(id)
  where pcon_code is null;

-- Local Authority boundaries (used to persist station LA codes)
create table if not exists la_boundaries (
  id bigint generated by default as identity primary key,
  la_code text not null,
  la_name text,
  la_version text not null,
  geometry geography(MultiPolygon, 4326),
  created_at timestamptz default now()
);
create unique index if not exists la_boundaries_code_version_uidx
  on la_boundaries(la_code, la_version);
create index if not exists la_boundaries_geom_idx on la_boundaries using gist (geometry);

create or replace function uk_aq_refresh_station_la_codes(target_version text)
returns integer
language plpgsql
set search_path = public, pg_catalog
as $$
declare
  updated_count integer;
begin
  perform set_config('statement_timeout', '15min', true);
  update stations st
  set la_code = lb.la_code,
      la_version = lb.la_version
  from la_boundaries lb
  where lb.la_version = target_version
    and st.geometry is not null
    and lb.geometry is not null
    and (st.la_code is null or st.la_version is distinct from target_version)
    and ST_Covers(lb.geometry::geometry, st.geometry::geometry);
  get diagnostics updated_count = row_count;
  return updated_count;
end;
$$;

create or replace function uk_aq_refresh_station_la_codes_partition(
  target_version text,
  partition_mod integer,
  partition_idx integer
)
returns integer
language plpgsql
set search_path = public, pg_catalog
as $$
declare
  updated_count integer;
begin
  if partition_mod <= 0 then
    raise exception 'partition_mod must be > 0';
  end if;
  if partition_idx < 0 or partition_idx >= partition_mod then
    raise exception 'partition_idx must be between 0 and %', partition_mod - 1;
  end if;

  perform set_config('statement_timeout', '15min', true);
  update stations st
  set la_code = lb.la_code,
      la_version = lb.la_version
  from la_boundaries lb
  where lb.la_version = target_version
    and st.geometry is not null
    and lb.geometry is not null
    and (st.la_code is null or st.la_version is distinct from target_version)
    and mod(st.id, partition_mod::bigint) = partition_idx::bigint
    and ST_Covers(lb.geometry::geometry, st.geometry::geometry);
  get diagnostics updated_count = row_count;
  return updated_count;
end;
$$;

-- Station LA queue (throttled updates)
create table if not exists station_la_queue (
  station_id bigint primary key references stations(id) on delete cascade,
  status text default 'pending',
  attempts integer default 0,
  last_error text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);
create index if not exists station_la_queue_status_idx
  on station_la_queue(status, created_at);

create or replace function uk_aq_enqueue_station_la()
returns trigger
language plpgsql
set search_path = public, pg_catalog
as $$
begin
  if new.geometry is not null and (new.la_code is null or new.la_version is null) then
    insert into station_la_queue (station_id, status, updated_at)
    values (new.id, 'pending', now())
    on conflict (station_id) do update
    set status = 'pending',
        updated_at = now();
  elsif new.la_code is not null and new.la_version is not null then
    update station_la_queue
    set status = 'done',
        updated_at = now()
    where station_id = new.id;
  end if;
  return new;
end;
$$;

do $$
begin
  if not exists (
    select 1
    from pg_trigger
    where tgname = 'stations_la_queue_enqueue'
  ) then
    create trigger stations_la_queue_enqueue
    after insert or update of geometry, la_code, la_version on stations
    for each row execute function uk_aq_enqueue_station_la();
  end if;
end $$;

create or replace function uk_aq_process_station_la_queue(
  target_version text,
  batch_limit integer default 5
)
returns integer
language plpgsql
set search_path = public, pg_catalog
as $$
declare
  updated_count integer;
  boundary_count integer;
begin
  if batch_limit is null or batch_limit <= 0 then
    raise exception 'batch_limit must be > 0';
  end if;

  select count(*) into boundary_count
  from la_boundaries
  where la_version = target_version;
  if boundary_count = 0 then
    return 0;
  end if;

  perform set_config('statement_timeout', '5min', true);

  with candidate as (
    select q.station_id
    from station_la_queue q
    join stations st on st.id = q.station_id
    where q.status = 'pending'
      and st.geometry is not null
      and (st.la_code is null or st.la_version is distinct from target_version)
    order by q.created_at
    for update skip locked
    limit batch_limit
  ),
  marked as (
    update station_la_queue q
    set status = 'processing',
        attempts = q.attempts + 1,
        updated_at = now()
    from candidate c
    where q.station_id = c.station_id
    returning q.station_id
  ),
  updated as (
    update stations st
    set la_code = lb.la_code,
        la_version = lb.la_version
    from la_boundaries lb,
      marked m
    where lb.la_version = target_version
      and m.station_id = st.id
      and st.geometry is not null
      and lb.geometry is not null
      and lb.geometry::geometry && st.geometry::geometry
      and ST_Covers(lb.geometry::geometry, st.geometry::geometry)
    returning st.id
  ),
  queue_update as (
    update station_la_queue q
    set status = case when u.id is not null then 'done' else 'pending' end,
        updated_at = now()
    from marked m
    left join updated u on u.id = m.station_id
    where q.station_id = m.station_id
    returning q.station_id
  )
  select count(*) into updated_count from updated;
  return updated_count;
end;
$$;

-- Parliamentary Constituency boundaries (used to persist station PCON codes)
create table if not exists pcon_boundaries (
  id bigint generated by default as identity primary key,
  pcon_code text not null,
  pcon_name text,
  pcon_version text not null,
  geometry geography(MultiPolygon, 4326),
  created_at timestamptz default now()
);
create unique index if not exists pcon_boundaries_code_version_uidx
  on pcon_boundaries(pcon_code, pcon_version);
create index if not exists pcon_boundaries_geom_idx on pcon_boundaries using gist (geometry);
create index if not exists pcon_boundaries_geom_cast_idx on pcon_boundaries using gist ((geometry::geometry));

create or replace function uk_aq_refresh_station_pcon_codes(target_version text)
returns integer
language plpgsql
set search_path = public, pg_catalog
as $$
declare
  updated_count integer;
begin
  update stations st
  set pcon_code = pb.pcon_code,
      pcon_version = pb.pcon_version
  from pcon_boundaries pb
  where pb.pcon_version = target_version
    and st.geometry is not null
    and pb.geometry is not null
    and (st.pcon_code is null or st.pcon_version is distinct from target_version)
    and ST_Covers(pb.geometry::geometry, st.geometry::geometry);
  get diagnostics updated_count = row_count;
  return updated_count;
end;
$$;

create or replace function uk_aq_refresh_station_pcon_codes_partition(
  target_version text,
  partition_mod integer,
  partition_idx integer
)
returns integer
language plpgsql
set search_path = public, pg_catalog
as $$
declare
  updated_count integer;
begin
  if partition_mod <= 0 then
    raise exception 'partition_mod must be > 0';
  end if;
  if partition_idx < 0 or partition_idx >= partition_mod then
    raise exception 'partition_idx must be between 0 and %', partition_mod - 1;
  end if;

  update stations st
  set pcon_code = pb.pcon_code,
      pcon_version = pb.pcon_version
  from pcon_boundaries pb
  where pb.pcon_version = target_version
    and st.geometry is not null
    and pb.geometry is not null
    and (st.pcon_code is null or st.pcon_version is distinct from target_version)
    and mod(st.id, partition_mod::bigint) = partition_idx::bigint
    and ST_Covers(pb.geometry::geometry, st.geometry::geometry);
  get diagnostics updated_count = row_count;
  return updated_count;
end;
$$;

-- Station PCON history (snapshot per boundary version)
create table if not exists station_pcon_history (
  id bigint generated by default as identity primary key,
  station_id bigint not null references stations(id) on delete cascade,
  pcon_code text not null,
  pcon_name text,
  pcon_version text not null,
  computed_at timestamptz default now()
);
create unique index if not exists station_pcon_history_station_version_uidx
  on station_pcon_history(station_id, pcon_version);
create index if not exists station_pcon_history_pcon_code_idx
  on station_pcon_history(pcon_code);
create index if not exists station_pcon_history_pcon_version_idx
  on station_pcon_history(pcon_version);

create or replace function uk_aq_refresh_station_pcon_history(target_version text)
returns integer
language plpgsql
set search_path = public, pg_catalog
as $$
declare
  upserted_count integer;
begin
  perform set_config('statement_timeout', '15min', true);
  insert into station_pcon_history (station_id, pcon_code, pcon_name, pcon_version)
  select
    st.id,
    pb.pcon_code,
    pb.pcon_name,
    pb.pcon_version
  from stations st
  join pcon_boundaries pb
    on pb.pcon_version = target_version
  where st.geometry is not null
    and pb.geometry is not null
    and ST_Covers(pb.geometry::geometry, st.geometry::geometry)
  on conflict (station_id, pcon_version) do update
  set pcon_code = excluded.pcon_code,
      pcon_name = excluded.pcon_name,
      computed_at = now();
  get diagnostics upserted_count = row_count;
  return upserted_count;
end;
$$;

create or replace function uk_aq_refresh_station_pcon_history_partition(
  target_version text,
  partition_mod int,
  partition_idx int
)
returns integer
language plpgsql
set search_path = public, pg_catalog
as $$
declare
  upserted_count integer;
begin
  if partition_mod is null or partition_mod <= 0 then
    raise exception 'partition_mod must be > 0';
  end if;
  if partition_idx is null or partition_idx < 0 or partition_idx >= partition_mod then
    raise exception 'partition_idx must be between 0 and partition_mod - 1';
  end if;

  perform set_config('statement_timeout', '15min', true);
  insert into station_pcon_history (station_id, pcon_code, pcon_name, pcon_version)
  select
    st.id,
    pb.pcon_code,
    pb.pcon_name,
    pb.pcon_version
  from stations st
  join pcon_boundaries pb
    on pb.pcon_version = target_version
  where st.geometry is not null
    and pb.geometry is not null
    and mod(st.id, partition_mod) = partition_idx
    and ST_Covers(pb.geometry::geometry, st.geometry::geometry)
  on conflict (station_id, pcon_version) do update
  set pcon_code = excluded.pcon_code,
      pcon_name = excluded.pcon_name,
      computed_at = now();
  get diagnostics upserted_count = row_count;
  return upserted_count;
end;
$$;

-- Station PCON queue (throttled updates)
create table if not exists station_pcon_queue (
  station_id bigint primary key references stations(id) on delete cascade,
  status text default 'pending',
  attempts integer default 0,
  last_error text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);
create index if not exists station_pcon_queue_status_idx
  on station_pcon_queue(status, created_at);

create or replace function uk_aq_enqueue_station_pcon()
returns trigger
language plpgsql
set search_path = public, pg_catalog
as $$
begin
  if new.geometry is not null and new.pcon_code is null then
    insert into station_pcon_queue (station_id, status, updated_at)
    values (new.id, 'pending', now())
    on conflict (station_id) do update
    set status = 'pending',
        updated_at = now();
  elsif new.pcon_code is not null then
    update station_pcon_queue
    set status = 'done',
        updated_at = now()
    where station_id = new.id;
  end if;
  return new;
end;
$$;

do $$
begin
  if not exists (
    select 1
    from pg_trigger
    where tgname = 'stations_pcon_queue_enqueue'
  ) then
    create trigger stations_pcon_queue_enqueue
    after insert or update of geometry, pcon_code on stations
    for each row execute function uk_aq_enqueue_station_pcon();
  end if;
end $$;

create or replace function uk_aq_process_station_pcon_queue(
  target_version text,
  batch_limit integer default 5
)
returns integer
language plpgsql
set search_path = public, pg_catalog
as $$
declare
  updated_count integer;
  boundary_count integer;
begin
  if batch_limit is null or batch_limit <= 0 then
    raise exception 'batch_limit must be > 0';
  end if;

  select count(*) into boundary_count
  from pcon_boundaries
  where pcon_version = target_version;
  if boundary_count = 0 then
    return 0;
  end if;

  perform set_config('statement_timeout', '5min', true);

  with candidate as (
    select q.station_id
    from station_pcon_queue q
    join stations st on st.id = q.station_id
    where q.status = 'pending'
      and st.geometry is not null
      and (st.pcon_code is null or st.pcon_version is distinct from target_version)
    order by q.created_at
    for update skip locked
    limit batch_limit
  ),
  marked as (
    update station_pcon_queue q
    set status = 'processing',
        attempts = q.attempts + 1,
        updated_at = now()
    from candidate c
    where q.station_id = c.station_id
    returning q.station_id
  ),
  updated as (
    update stations st
    set pcon_code = pb.pcon_code,
        pcon_version = pb.pcon_version
    from pcon_boundaries pb,
      marked m
    where pb.pcon_version = target_version
      and m.station_id = st.id
      and st.geometry is not null
      and pb.geometry is not null
      and pb.geometry::geometry && st.geometry::geometry
      and ST_Covers(pb.geometry::geometry, st.geometry::geometry)
    returning st.id
  ),
  queue_update as (
    update station_pcon_queue q
    set status = case when u.id is not null then 'done' else 'pending' end,
        updated_at = now()
    from marked m
    left join updated u on u.id = m.station_id
    where q.station_id = m.station_id
    returning q.station_id
  )
  select count(*) into updated_count from updated;
  return updated_count;
end;
$$;

create or replace function uk_aq_stations_with_pcon(target_version text)
returns table (
  station_id bigint,
  station_ref text,
  label text,
  station_type text,
  station_exposure text,
  region text,
  la_code text,
  la_version text,
  pcon_code text,
  pcon_name text,
  pcon_version text,
  geometry geography(Point, 4326),
  connector_id bigint,
  category_id bigint,
  first_seen_at timestamptz,
  last_seen_at timestamptz,
  removed_at timestamptz,
  created_at timestamptz
)
language sql
set search_path = public, pg_catalog
as $$
  select
    st.id as station_id,
    st.station_ref,
    st.label,
    st.station_type,
    st.station_exposure,
    st.region,
    st.la_code,
    st.la_version,
    sph.pcon_code,
    sph.pcon_name,
    sph.pcon_version,
    st.geometry,
    st.connector_id,
    st.category_id,
    st.first_seen_at,
    st.last_seen_at,
    st.removed_at,
    st.created_at
  from stations st
  left join station_pcon_history sph
    on sph.station_id = st.id
    and sph.pcon_version = target_version;
$$;

create or replace function uk_aq_fix_station_geometry_swapped()
returns integer
language plpgsql
set search_path = public, pg_catalog
as $$
declare
  updated_count integer;
begin
  update stations
  set geometry = ST_SetSRID(
    ST_MakePoint(
      ST_Y(geometry::geometry),
      ST_X(geometry::geometry)
    ),
    4326
  )::geography
  where geometry is not null
    and ST_X(geometry::geometry) between 49 and 61
    and ST_Y(geometry::geometry) between -10 and 10;
  get diagnostics updated_count = row_count;
  return updated_count;
end;
$$;

-- Parliamentary constituencies (current + legacy electorates)
create table if not exists pcon_current (
  id bigint generated by default as identity primary key,
  gss_code text not null,
  name text not null,
  electorate int,
  region text,
  country text,
  created_at timestamptz default now()
);
create unique index if not exists pcon_current_gss_code_uidx on pcon_current(gss_code);

create table if not exists pcon_legacy (
  id bigint generated by default as identity primary key,
  gss_code text not null,
  name text not null,
  electorate int,
  region text,
  country text,
  created_at timestamptz default now()
);
create unique index if not exists pcon_legacy_gss_code_uidx on pcon_legacy(gss_code);

-- Canonical GSS codes registry (shared across geographies)
create table if not exists gss_codes (
  id bigint generated by default as identity primary key,
  gss_code text not null,
  name text,
  geography_type text,
  valid_from date,
  valid_to date
);
create unique index if not exists gss_codes_gss_code_uidx on gss_codes(gss_code);

-- GSS region name lookup (hex map metadata)
create table if not exists uk_aq_region_names (
  region_code text primary key,
  region_name text not null,
  created_at timestamptz default now()
);

insert into uk_aq_region_names (region_code, region_name)
values
  ('E12000001', 'North East'),
  ('E12000002', 'North West'),
  ('E12000003', 'Yorkshire and The Humber'),
  ('E12000004', 'East Midlands'),
  ('E12000005', 'West Midlands'),
  ('E12000006', 'East of England'),
  ('E12000007', 'London'),
  ('E12000008', 'South East'),
  ('E12000009', 'South West'),
  ('S92000003', 'Scotland'),
  ('W92000004', 'Wales'),
  ('N92000002', 'Northern Ireland')
on conflict (region_code) do update
set region_name = excluded.region_name;

-- Air quality guideline limits (WHO/UK/EU, etc.)
create table if not exists uk_aq_guidelines (
  id bigint generated by default as identity primary key,
  pollutant text not null,
  averaging_period_label text not null,
  averaging_period_interval interval,
  level_label text not null,
  limit_value numeric not null,
  uom text not null,
  source text,
  notes text,
  valid_from date,
  valid_to date,
  created_at timestamptz default now()
);
create unique index if not exists uk_aq_guidelines_uidx
  on uk_aq_guidelines(pollutant, averaging_period_label, level_label, source);

-- Timeseries metadata
create table if not exists timeseries (
  id bigint generated by default as identity primary key,
  timeseries_ref text not null,
  label text not null,
  uom text,
  station_id bigint references stations(id) on delete cascade,
  service_ref text not null,
  connector_id bigint not null references connectors(id) on delete cascade,
  offering_id bigint references offerings(id),
  feature_id bigint references features(id),
  procedure_id bigint references procedures(id),
  phenomenon_id bigint references phenomena(id),
  category_id bigint references categories(id),
  first_value_at timestamptz,
  last_value_at timestamptz,
  last_value numeric,
  extras jsonb,
  rendering_hints jsonb,
  status_intervals jsonb,
  created_at timestamptz default now()
);

create unique index if not exists timeseries_connector_ref_uidx
  on timeseries(connector_id, service_ref, timeseries_ref);
create index if not exists timeseries_station_idx on timeseries(station_id);
create index if not exists timeseries_phenomenon_idx on timeseries(phenomenon_id);
create index if not exists timeseries_phenomenon_station_idx on timeseries(phenomenon_id, station_id);

-- Reference values attached to a timeseries
create table if not exists reference_values (
  id uuid default gen_random_uuid() primary key,
  timeseries_id bigint references timeseries(id) on delete cascade,
  name text,
  color text,
  value numeric,
  created_at timestamptz default now()
);

-- Observations (time-value pairs)
create table if not exists observations (
  timeseries_id bigint references timeseries(id) on delete cascade,
  observed_at timestamptz not null,
  value numeric,
  status text,
  created_at timestamptz default now(),
  primary key (timeseries_id, observed_at)
);
create index if not exists observations_time_idx on observations(observed_at);

-- Ingest run summaries
create table if not exists uk_aq_ingest_runs (
  id bigint generated by default as identity primary key,
  connector_id bigint references connectors(id) on delete set null,
  connector_code text not null,
  run_started_at timestamptz,
  run_ended_at timestamptz,
  run_status text,
  run_message text,
  last_observed_at timestamptz,
  stations_updated int,
  observations_upserted int,
  timeseries_updated int,
  series_polled int,
  response_status int,
  response_payload jsonb,
  created_at timestamptz default now()
);

create index if not exists uk_aq_ingest_runs_connector_idx on uk_aq_ingest_runs(connector_code);
create index if not exists uk_aq_ingest_runs_run_end_idx on uk_aq_ingest_runs(run_ended_at desc);

-- Error logs
create table if not exists error_logs (
  id uuid default gen_random_uuid() primary key,
  created_at timestamptz default now(),
  source text not null,
  severity text not null,
  message text not null,
  stack text,
  context jsonb,
  connector_id bigint references connectors(id) on delete set null,
  station_id bigint references stations(id) on delete set null,
  timeseries_id bigint references timeseries(id) on delete set null,
  dropbox_path text
);
create index if not exists error_logs_created_at_idx on error_logs(created_at desc);
create index if not exists error_logs_source_idx on error_logs(source);
create index if not exists error_logs_connector_idx on error_logs(connector_id);

-- PM2.5 Population Exposure Indicator progress (PERT)
create table if not exists pm25_population_exposure (
  id bigint generated by default as identity primary key,
  year int unique,
  pei_base numeric,
  pei numeric,
  yearly_change numeric,
  cumulative_change numeric,
  cumulative_change_pct numeric,
  collected_at timestamptz default now()
);

-- PM2.5 Annual Mean Concentration Target stats (AMCT)
create table if not exists pm25_amct_sites (
  id bigint generated by default as identity primary key,
  site_code text,
  site_name text,
  year int,
  annual_mean numeric,
  exceeded_interim boolean,
  exceeded_final boolean,
  data_capture_ok boolean,
  collected_at timestamptz default now()
);
create index if not exists pm25_amct_site_year_idx on pm25_amct_sites(site_code, year);

-- ----------------------------
-- Row Level Security (RLS)
-- ----------------------------
-- Enable RLS on all tables and add safe-to-reapply policies:
--   - authenticated + service_role: read
--   - service_role: write
-- Assumes Supabase roles where auth.role() is available.

-- Enable RLS
alter table if exists connectors enable row level security;
alter table if exists categories enable row level security;
alter table if exists phenomena enable row level security;
alter table if exists offerings enable row level security;
alter table if exists features enable row level security;
alter table if exists procedures enable row level security;
alter table if exists stations enable row level security;
alter table if exists station_metadata enable row level security;
alter table if exists station_network_memberships enable row level security;
alter table if exists uk_aq_networks enable row level security;
alter table if exists uk_air_sos_networks enable row level security;
alter table if exists uk_air_sos_network_pollutants enable row level security;
alter table if exists uk_air_sos_site_register enable row level security;
alter table if exists laqn_site_register enable row level security;
alter table if exists uk_air_sos_station_refs enable row level security;
alter table if exists breathelondon_timeseries_checkpoints enable row level security;
alter table if exists erg_laqn_station_checkpoints enable row level security;
alter table if exists uk_air_sos_timeseries_checkpoints enable row level security;
alter table if exists timeseries enable row level security;
alter table if exists reference_values enable row level security;
alter table if exists observations enable row level security;
alter table if exists uk_aq_ingest_runs enable row level security;
alter table if exists error_logs enable row level security;
alter table if exists pm25_population_exposure enable row level security;
alter table if exists pm25_amct_sites enable row level security;
alter table if exists la_boundaries enable row level security;
alter table if exists station_la_queue enable row level security;
alter table if exists pcon_boundaries enable row level security;
alter table if exists station_pcon_history enable row level security;
alter table if exists station_pcon_queue enable row level security;
alter table if exists pcon_current enable row level security;
alter table if exists pcon_legacy enable row level security;
alter table if exists gss_codes enable row level security;
alter table if exists uk_aq_region_names enable row level security;
alter table if exists uk_aq_guidelines enable row level security;

-- Helper DO block to add policies idempotently
do $$
declare
  t text;
begin
  for t in select unnest(array[
    'connectors','categories','phenomena','offerings','features','procedures','stations','station_metadata','station_network_memberships','uk_aq_networks','uk_air_sos_networks','uk_air_sos_network_pollutants','uk_air_sos_site_register','laqn_site_register','uk_air_sos_station_refs','breathelondon_timeseries_checkpoints','erg_laqn_station_checkpoints','uk_air_sos_timeseries_checkpoints','timeseries','reference_values','observations','uk_aq_ingest_runs','pm25_population_exposure','pm25_amct_sites','la_boundaries','station_la_queue','pcon_boundaries','station_pcon_history','station_pcon_queue','pcon_current','pcon_legacy','gss_codes','uk_aq_region_names','uk_aq_guidelines'
  ])
  loop
    -- Read policy for authenticated + service_role
    if not exists (
      select 1 from pg_policies p
      where p.schemaname = current_schema()
        and p.tablename = t
        and p.policyname = t || '_select_authenticated'
    ) then
      execute format(
        'create policy %I on %I for select using (auth.role() in (''authenticated'',''service_role''));',
        t || '_select_authenticated', t
      );
    end if;

    -- Write policy for service_role
    if not exists (
      select 1 from pg_policies p
      where p.schemaname = current_schema()
        and p.tablename = t
        and p.policyname = t || '_write_service_role'
    ) then
      execute format(
        'create policy %I on %I for all using (auth.role() = ''service_role'') with check (auth.role() = ''service_role'');',
        t || '_write_service_role', t
      );
    end if;
  end loop;
end $$;

-- error_logs policies: service_role only
do $$
begin
  if not exists (
    select 1 from pg_policies p
    where p.schemaname = current_schema()
      and p.tablename = 'error_logs'
      and p.policyname = 'error_logs_select_service_role'
  ) then
    execute
      'create policy error_logs_select_service_role on error_logs for select using (auth.role() = ''service_role'');';
  end if;

  if not exists (
    select 1 from pg_policies p
    where p.schemaname = current_schema()
      and p.tablename = 'error_logs'
      and p.policyname = 'error_logs_write_service_role'
  ) then
    execute
      'create policy error_logs_write_service_role on error_logs for all using (auth.role() = ''service_role'') with check (auth.role() = ''service_role'');';
  end if;
end $$;

-- pollutant_thresholds policies (table is created in uk_air_quality_views.sql)
alter table if exists pollutant_thresholds enable row level security;

do $$
begin
  if to_regclass('public.pollutant_thresholds') is null then
    return;
  end if;

  if not exists (
    select 1 from pg_policies p
    where p.schemaname = current_schema()
      and p.tablename = 'pollutant_thresholds'
      and p.policyname = 'pollutant_thresholds_select_authenticated'
  ) then
    execute
      'create policy pollutant_thresholds_select_authenticated on pollutant_thresholds '
      'for select using (auth.role() in (''authenticated'',''service_role''));';
  end if;

  if not exists (
    select 1 from pg_policies p
    where p.schemaname = current_schema()
      and p.tablename = 'pollutant_thresholds'
      and p.policyname = 'pollutant_thresholds_write_service_role'
  ) then
    execute
      'create policy pollutant_thresholds_write_service_role on pollutant_thresholds '
      'for all using (auth.role() = ''service_role'') with check (auth.role() = ''service_role'');';
  end if;
end $$;

-- PostGIS system table: enable RLS if we own it; otherwise skip.
do $$
declare
  owner_name text;
begin
  select r.rolname into owner_name
  from pg_class c
  join pg_roles r on r.oid = c.relowner
  where c.relname = 'spatial_ref_sys'
    and c.relnamespace = 'public'::regnamespace;

  if owner_name is null then
    raise notice 'spatial_ref_sys not found; skipping RLS setup.';
    return;
  end if;

  if owner_name = current_user then
    execute 'alter table public.spatial_ref_sys enable row level security';
    if not exists (
      select 1 from pg_policies p
      where p.schemaname = current_schema()
        and p.tablename = 'spatial_ref_sys'
        and p.policyname = 'spatial_ref_sys_select_all'
    ) then
      execute
        'create policy spatial_ref_sys_select_all on public.spatial_ref_sys for select using (auth.role() in (''anon'',''authenticated'',''service_role''));';
    end if;
  else
    raise notice 'Skipping RLS on public.spatial_ref_sys; owner is %, current_user is %', owner_name, current_user;
  end if;
exception when insufficient_privilege then
  raise notice 'Skipping RLS on public.spatial_ref_sys due to insufficient privileges.';
end $$;
