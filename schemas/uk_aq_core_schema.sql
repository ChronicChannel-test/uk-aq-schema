-- uk_aq_core schema (split from uk_air_quality_schema.sql)
-- UK Air Quality schema (bigint IDs + external *_ref fields)
-- External identifiers that arrive as text (even if numeric) use *_ref.
-- Internal joins always use bigint *_id columns.
-- Safe to rerun; uses IF NOT EXISTS where appropriate.

-- Ensure needed extensions
-- PostGIS remains in public on Supabase hosted Postgres.
create extension if not exists postgis;
create extension if not exists pgcrypto;

-- Connectors (external data sources)

create schema if not exists uk_aq_core;
set search_path = uk_aq_core, public;

create table if not exists connectors (
  id bigint generated by default as identity primary key,
  connector_code text not null,
  label text not null,
  display_name text,
  service_url text,
  station_display_name_template text,
  overwrite_station_name boolean default true,
  poll_enabled boolean default true,
  poll_interval_minutes int default 60,
  poll_window_hours int default 6,
  poll_timeseries_batch_size int,
  stations_bbox_supported boolean default true,
  timeseries_station_filter_supported boolean default true,
  last_polled_at timestamptz,
  last_run_start timestamptz,
  last_run_end timestamptz,
  last_run_status text,
  last_run_message text,
  created_at timestamptz default now()
);

create unique index if not exists connectors_connector_code_uidx on connectors(connector_code);

-- Default flags for known connectors (applies on insert; update existing rows if present).
create or replace function connectors_apply_known_defaults()
returns trigger
set search_path = uk_aq_core, public, pg_catalog
as $$
begin
  new.display_name = coalesce(new.display_name, new.label);
  if new.service_url = 'https://uk-air.defra.gov.uk/sos-ukair/api/v1'
     or new.label = 'UK-AIR-SOS' then
    new.stations_bbox_supported = false;
    new.timeseries_station_filter_supported = false;
  end if;
  if new.connector_code = 'sensorcommunity'
     or new.label = 'Sensor.Community' then
    new.overwrite_station_name = false;
  end if;
  return new;
end;
$$ language plpgsql;

drop trigger if exists connectors_apply_known_defaults on connectors;
create trigger connectors_apply_known_defaults
before insert on connectors
for each row execute function connectors_apply_known_defaults();

-- Categories

create table if not exists categories (
  id bigint generated by default as identity primary key,
  category_ref text not null,
  label text not null,
  connector_id bigint not null references connectors(id) on delete cascade
);

create unique index if not exists categories_connector_ref_uidx on categories(connector_id, category_ref);

-- Phenomena (pollutants)

create table if not exists phenomena (
  id bigint generated by default as identity primary key,
  label text not null,
  eionet_uri text,
  notation text,
  pollutant_label text,
  connector_id bigint not null references connectors(id) on delete cascade
);

create unique index if not exists phenomena_service_eionet_uidx
  on phenomena(connector_id, eionet_uri);

-- Offerings

create table if not exists offerings (
  id bigint generated by default as identity primary key,
  offering_ref text not null,
  label text not null,
  service_ref text not null,
  connector_id bigint not null references connectors(id) on delete cascade
);

create unique index if not exists offerings_connector_ref_uidx
  on offerings(connector_id, service_ref, offering_ref);

-- Features of interest (sites/areas)

create table if not exists features (
  id bigint generated by default as identity primary key,
  feature_ref text not null,
  label text not null,
  geometry geography(Point, 4326),
  service_ref text not null,
  connector_id bigint not null references connectors(id) on delete cascade
);

create unique index if not exists features_connector_ref_uidx
  on features(connector_id, service_ref, feature_ref);

-- Procedures (sensors/methods)

create table if not exists procedures (
  id bigint generated by default as identity primary key,
  procedure_ref text not null,
  label text not null,
  raw_formats text[],
  service_ref text not null,
  connector_id bigint not null references connectors(id) on delete cascade
);

create unique index if not exists procedures_connector_ref_uidx
  on procedures(connector_id, service_ref, procedure_ref);

-- Stations

create table if not exists stations (
  id bigint generated by default as identity primary key,
  station_ref text not null,
  service_ref text not null,
  label text not null,
  station_name text,
  station_type text,
  station_exposure text,
  region text,
  la_code text,
  la_version text,
  pcon_code text,
  pcon_version text,
  geometry geography(Point, 4326),
  connector_id bigint not null references connectors(id) on delete cascade,
  category_id bigint references categories(id),
  first_seen_at timestamptz default now(),
  last_seen_at timestamptz,
  removed_at timestamptz,
  created_at timestamptz default now()
);

create table if not exists station_metadata (
  station_id bigint primary key references stations(id) on delete cascade,
  attributes jsonb not null default '{}'::jsonb,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create table if not exists station_network_memberships (
  station_id bigint not null references stations(id) on delete cascade,
  network_code text not null,
  network_label text,
  is_primary boolean default false,
  created_at timestamptz default now(),
  primary key (station_id, network_code)
);

create table if not exists uk_aq_networks (
  id bigint generated by default as identity primary key,
  network_code text not null,
  display_name text not null,
  connector_code text not null references connectors(connector_code),
  is_active boolean default true,
  created_at timestamptz default now()
);

create unique index if not exists uk_aq_networks_network_code_uidx
  on uk_aq_networks(network_code);

create index if not exists uk_aq_networks_connector_code_idx
  on uk_aq_networks(connector_code);

-- Optional FK (validate after seeding uk_aq_networks).
do $$
begin
  if not exists (
    select 1
    from pg_constraint
    where conname = 'station_network_memberships_network_code_fkey'
      and conrelid = 'station_network_memberships'::regclass
  ) then
    execute
      'alter table if exists station_network_memberships '
      'add constraint station_network_memberships_network_code_fkey '
      'foreign key (network_code) references uk_aq_networks(network_code) '
      'not valid';
  end if;
end $$;

create table if not exists uk_air_sos_networks (
  network_ref text primary key,
  network_code text,
  network_display_name text,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create unique index if not exists uk_air_sos_networks_network_code_uidx
  on uk_air_sos_networks(network_code)
  where network_code is not null;

create table if not exists uk_air_sos_network_pollutants (
  network_ref text not null references uk_air_sos_networks(network_ref) on delete cascade,
  match_type text not null default 'contains',
  match_value text not null,
  created_at timestamptz default now(),
  primary key (network_ref, match_type, match_value)
);

create or replace function uk_aq_fix_station_geometry_swapped()
returns integer
language plpgsql
set search_path = uk_aq_core, public, pg_catalog
as $$
declare
  updated_count integer;
begin
  update stations
  set geometry = ST_SetSRID(
    ST_MakePoint(
      ST_Y(geometry::geometry),
      ST_X(geometry::geometry)
    ),
    4326
  )::geography
  where geometry is not null
    and ST_X(geometry::geometry) between 49 and 61
    and ST_Y(geometry::geometry) between -10 and 10;
  get diagnostics updated_count = row_count;
  return updated_count;
end;
$$;

-- Parliamentary constituencies (current + legacy electorates)

create table if not exists pcon_current (
  id bigint generated by default as identity primary key,
  gss_code text not null,
  name text not null,
  electorate int,
  region text,
  country text,
  created_at timestamptz default now()
);
create unique index if not exists pcon_current_gss_code_uidx on pcon_current(gss_code);

create table if not exists pcon_legacy (
  id bigint generated by default as identity primary key,
  gss_code text not null,
  name text not null,
  electorate int,
  region text,
  country text,
  created_at timestamptz default now()
);
create unique index if not exists pcon_legacy_gss_code_uidx on pcon_legacy(gss_code);

-- Canonical GSS codes registry (shared across geographies)

create table if not exists gss_codes (
  id bigint generated by default as identity primary key,
  gss_code text not null,
  name text,
  geography_type text,
  valid_from date,
  valid_to date
);
create unique index if not exists gss_codes_gss_code_uidx on gss_codes(gss_code);

-- GSS region name lookup (hex map metadata)

create table if not exists uk_aq_region_names (
  region_code text primary key,
  region_name text not null,
  created_at timestamptz default now()
);

insert into uk_aq_region_names (region_code, region_name)
values
  ('E12000001', 'North East'),
  ('E12000002', 'North West'),
  ('E12000003', 'Yorkshire and The Humber'),
  ('E12000004', 'East Midlands'),
  ('E12000005', 'West Midlands'),
  ('E12000006', 'East of England'),
  ('E12000007', 'London'),
  ('E12000008', 'South East'),
  ('E12000009', 'South West'),
  ('S92000003', 'Scotland'),
  ('W92000004', 'Wales'),
  ('N92000002', 'Northern Ireland')
on conflict (region_code) do update
set region_name = excluded.region_name;

-- Air quality guideline limits (WHO/UK/EU, etc.)

create table if not exists uk_aq_guidelines (
  id bigint generated by default as identity primary key,
  pollutant text not null,
  averaging_period_label text not null,
  averaging_period_interval interval,
  level_label text not null,
  limit_value numeric not null,
  uom text not null,
  source text,
  notes text,
  valid_from date,
  valid_to date,
  created_at timestamptz default now()
);
create unique index if not exists uk_aq_guidelines_uidx
  on uk_aq_guidelines(pollutant, averaging_period_label, level_label, source);

-- Timeseries metadata

create table if not exists timeseries (
  id bigint generated by default as identity primary key,
  timeseries_ref text not null,
  label text not null,
  uom text,
  station_id bigint references stations(id) on delete cascade,
  service_ref text not null,
  connector_id bigint not null references connectors(id) on delete cascade,
  offering_id bigint references offerings(id),
  feature_id bigint references features(id),
  procedure_id bigint references procedures(id),
  phenomenon_id bigint references phenomena(id),
  category_id bigint references categories(id),
  first_value_at timestamptz,
  last_value_at timestamptz,
  last_value numeric,
  extras jsonb,
  rendering_hints jsonb,
  status_intervals jsonb,
  created_at timestamptz default now()
);

create unique index if not exists timeseries_connector_ref_uidx
  on timeseries(connector_id, service_ref, timeseries_ref);
create index if not exists timeseries_station_idx on timeseries(station_id);
create index if not exists timeseries_phenomenon_idx on timeseries(phenomenon_id);
create index if not exists timeseries_phenomenon_station_idx on timeseries(phenomenon_id, station_id);

-- Reference values attached to a timeseries

create table if not exists reference_values (
  id uuid default gen_random_uuid() primary key,
  timeseries_id bigint references timeseries(id) on delete cascade,
  name text,
  color text,
  value numeric,
  created_at timestamptz default now()
);

-- Observations (time-value pairs)

create table if not exists observations (
  timeseries_id bigint references timeseries(id) on delete cascade,
  observed_at timestamptz not null,
  value numeric,
  status text,
  created_at timestamptz default now(),
  primary key (timeseries_id, observed_at)
);
create index if not exists observations_time_idx on observations(observed_at);

-- Ingest run summaries

create table if not exists uk_aq_ingest_runs (
  id bigint generated by default as identity primary key,
  connector_id bigint references connectors(id) on delete set null,
  connector_code text not null,
  run_started_at timestamptz,
  run_ended_at timestamptz,
  run_status text,
  run_message text,
  last_observed_at timestamptz,
  stations_updated int,
  observations_upserted int,
  timeseries_updated int,
  series_polled int,
  response_status int,
  response_payload jsonb,
  created_at timestamptz default now()
);

create index if not exists uk_aq_ingest_runs_connector_idx on uk_aq_ingest_runs(connector_code);
create index if not exists uk_aq_ingest_runs_run_end_idx on uk_aq_ingest_runs(run_ended_at desc);


-- Pollutant thresholds for DAQI (used by Bristol view)
create table if not exists pollutant_thresholds (
  pollutant text,
  band int,
  label text,
  color text,
  lower_value numeric,
  upper_value numeric,
  uom text,
  primary key (pollutant, band)
);

insert into pollutant_thresholds (pollutant, band, label, color, lower_value, upper_value, uom)
values
  ('no2', 1, 'DAQI 1-3 (Low)', '#79BC6A', 0, 67, 'µg/m³'),
  ('no2', 2, 'DAQI 4-6 (Moderate)', '#BBCF4C', 68, 134, 'µg/m³'),
  ('no2', 3, 'DAQI 7-9 (High)', '#EEC20B', 135, 200, 'µg/m³'),
  ('no2', 4, 'DAQI 10 (Very High)', '#F29305', 201, null, 'µg/m³'),
  ('o3', 1, 'DAQI 1-3 (Low)', '#79BC6A', 0, 99, 'µg/m³'),
  ('o3', 2, 'DAQI 4-6 (Moderate)', '#BBCF4C', 100, 159, 'µg/m³'),
  ('o3', 3, 'DAQI 7-9 (High)', '#EEC20B', 160, 239, 'µg/m³'),
  ('o3', 4, 'DAQI 10 (Very High)', '#F29305', 240, null, 'µg/m³'),
  ('pm10', 1, 'DAQI 1-3 (Low)', '#79BC6A', 0, 16, 'µg/m³'),
  ('pm10', 2, 'DAQI 4-6 (Moderate)', '#BBCF4C', 17, 49, 'µg/m³'),
  ('pm10', 3, 'DAQI 7-9 (High)', '#EEC20B', 50, 75, 'µg/m³'),
  ('pm10', 4, 'DAQI 10 (Very High)', '#F29305', 76, null, 'µg/m³'),
  ('pm2.5', 1, 'DAQI 1-3 (Low)', '#79BC6A', 0, 11, 'µg/m³'),
  ('pm2.5', 2, 'DAQI 4-6 (Moderate)', '#BBCF4C', 12, 35, 'µg/m³'),
  ('pm2.5', 3, 'DAQI 7-9 (High)', '#EEC20B', 36, 53, 'µg/m³'),
  ('pm2.5', 4, 'DAQI 10 (Very High)', '#F29305', 54, null, 'µg/m³')
on conflict (pollutant, band) do update
set label = excluded.label,
    color = excluded.color,
    lower_value = excluded.lower_value,
    upper_value = excluded.upper_value,
    uom = excluded.uom;

-- UK-AIR SOS timeseries polling helper
create or replace function uk_air_sos_select_timeseries_ids(
  batch_limit integer default 200
)
returns bigint[]
language plpgsql
set search_path = uk_aq_core, uk_aq_raw, public, pg_catalog
as $$
declare
  v_connector_id bigint;
  series_ids bigint[];
begin
  select id into v_connector_id
  from connectors
  where connector_code = 'uk_air_sos'
  limit 1;

  if v_connector_id is null then
    return null;
  end if;

  with candidates as (
    select ts.id
    from timeseries ts
    left join uk_air_sos_timeseries_checkpoints chk on chk.timeseries_id = ts.id
    where ts.connector_id = v_connector_id
    order by (chk.last_polled_at is not null),
      chk.last_polled_at,
      ts.id
    limit batch_limit
  )
  select array_agg(id) into series_ids
  from candidates;

  return series_ids;
end;
$$;

-- Local authority latest PM2.5 (median + mean) derived from station LA codes.
create or replace view la_latest_pm25 as
with pm25_candidates as (
  select
    ts.station_id,
    ts.last_value,
    ts.last_value_at,
    row_number() over (
      partition by ts.station_id
      order by ts.last_value_at desc nulls last
    ) as rn
  from timeseries ts
  join phenomena phen on phen.id = ts.phenomenon_id
  where ts.station_id is not null
    and ts.last_value is not null
    and ts.last_value_at is not null
    and ts.last_value >= 0
    and (
      lower(coalesce(phen.pollutant_label, '')) = 'pm2.5'
      or lower(coalesce(phen.notation, '')) = 'pm2.5'
      or lower(coalesce(phen.label, '')) like '%pm2.5%'
    )
),
pm25_latest as (
  select
    stn.la_code,
    stn.la_version,
    pm.last_value,
    pm.last_value_at
  from pm25_candidates pm
  join stations stn on stn.id = pm.station_id
  where pm.rn = 1
    and stn.la_code is not null
),
pm25_agg as (
  select
    la_code,
    la_version,
    count(*)::int as station_count,
    percentile_cont(0.5) within group (order by last_value) as median_value,
    avg(last_value) as mean_value,
    max(last_value_at) as latest_value_at
  from pm25_latest
  group by la_code, la_version
)
select
  pm25_agg.la_code,
  gc.name as la_name,
  pm25_agg.la_version,
  pm25_agg.station_count,
  (pm25_agg.station_count = 1) as single_site,
  pm25_agg.median_value,
  pm25_agg.mean_value,
  pm25_agg.latest_value_at
from pm25_agg
left join gss_codes gc
  on gc.gss_code = pm25_agg.la_code;

-- Parliamentary constituency latest PM2.5 (median + mean) derived from station PCON codes.
create or replace view pcon_latest_pm25 as
with pm25_candidates as (
  select
    ts.station_id,
    ts.last_value,
    ts.last_value_at,
    row_number() over (
      partition by ts.station_id
      order by ts.last_value_at desc nulls last
    ) as rn
  from timeseries ts
  join phenomena phen on phen.id = ts.phenomenon_id
  where ts.station_id is not null
    and ts.last_value is not null
    and ts.last_value_at is not null
    and ts.last_value >= 0
    and (
      lower(coalesce(phen.pollutant_label, '')) = 'pm2.5'
      or lower(coalesce(phen.notation, '')) = 'pm2.5'
      or lower(coalesce(phen.label, '')) like '%pm2.5%'
    )
),
pm25_latest as (
  select
    stn.pcon_code,
    stn.pcon_version,
    pm.last_value,
    pm.last_value_at
  from pm25_candidates pm
  join stations stn on stn.id = pm.station_id
  where pm.rn = 1
    and stn.pcon_code is not null
),
pm25_agg as (
  select
    pcon_code,
    pcon_version,
    count(*)::int as station_count,
    percentile_cont(0.5) within group (order by last_value) as median_value,
    avg(last_value) as mean_value,
    max(last_value_at) as latest_value_at
  from pm25_latest
  group by pcon_code, pcon_version
)
select
  pm25_agg.pcon_code,
  coalesce(pc.name, pl.name, gc.name) as pcon_name,
  pm25_agg.pcon_version,
  pm25_agg.station_count,
  (pm25_agg.station_count = 1) as single_site,
  pm25_agg.median_value,
  pm25_agg.mean_value,
  pm25_agg.latest_value_at
from pm25_agg
left join pcon_current pc
  on pc.gss_code = pm25_agg.pcon_code
left join pcon_legacy pl
  on pl.gss_code = pm25_agg.pcon_code
left join gss_codes gc
  on gc.gss_code = pm25_agg.pcon_code;
