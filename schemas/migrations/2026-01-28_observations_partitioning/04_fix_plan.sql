-- 04_fix_plan.sql
-- Fix plan for observations partition migration.
-- Apply selectively: each section is optional and marked.

set search_path = uk_aq_core, public;

-- =========================================================
-- [OPTIONAL] Create (timeseries_id, observed_at desc) index on parent
-- This will create partition indexes in PostgreSQL.
-- =========================================================
-- create index if not exists observations_ts_time_desc_idx
--   on uk_aq_core.observations(timeseries_id, observed_at desc);

-- =========================================================
-- [OPTIONAL] Drop redundant observed_at-only indexes if unnecessary
-- (Use audit results to decide; comment out to keep.)
-- =========================================================
-- drop index if exists uk_aq_core.observations_time_idx;

-- =========================================================
-- [OPTIONAL] Fix connector_id mismatches vs timeseries
-- (Moves rows to correct partition automatically.)
-- =========================================================
-- update uk_aq_core.observations o
-- set connector_id = t.connector_id
-- from uk_aq_core.timeseries t
-- where o.timeseries_id = t.id
--   and o.connector_id <> t.connector_id;

-- =========================================================
-- [OPTIONAL] Guard trigger to enforce connector_id correctness
-- Default recommendation: keep off unless you need strict enforcement.
-- =========================================================
-- create or replace function uk_aq_core.observations_enforce_connector_id()
-- returns trigger
-- language plpgsql
-- set search_path = uk_aq_core, public, pg_catalog
-- as $$
-- declare
--   v_connector_id bigint;
-- begin
--   select connector_id into v_connector_id
--   from uk_aq_core.timeseries
--   where id = new.timeseries_id;
--
--   if v_connector_id is null then
--     raise exception 'timeseries_id % does not exist', new.timeseries_id;
--   end if;
--
--   if new.connector_id is null then
--     new.connector_id := v_connector_id;
--   elsif new.connector_id <> v_connector_id then
--     raise exception 'observations.connector_id (%) does not match timeseries.connector_id (%) for timeseries_id %',
--       new.connector_id, v_connector_id, new.timeseries_id;
--   end if;
--
--   return new;
-- end;
-- $$;
--
-- drop trigger if exists observations_enforce_connector_id on uk_aq_core.observations;
-- create trigger observations_enforce_connector_id
-- before insert or update on uk_aq_core.observations
-- for each row execute function uk_aq_core.observations_enforce_connector_id();

-- =========================================================
-- [OPTIONAL] Partition onboarding helper (idempotent)
-- Creates a partition for a connector_id and optionally moves rows from DEFAULT.
-- =========================================================
-- create or replace function uk_aq_core.observations_create_partition(
--   p_connector_id bigint,
--   p_move_from_default boolean default true
-- )
-- returns void
-- language plpgsql
-- set search_path = uk_aq_core, public, pg_catalog
-- as $$
-- declare
--   partition_name text;
--   default_exists boolean;
-- begin
--   if p_connector_id is null then
--     raise exception 'connector_id is required';
--   end if;
--
--   partition_name := format('observations_new_c_%s', replace(p_connector_id::text, '-', '_'));
--   execute format(
--     'create table if not exists uk_aq_core.%I partition of uk_aq_core.observations for values in (%L);',
--     partition_name,
--     p_connector_id
--   );
--
--   select to_regclass('uk_aq_core.observations_default') is not null into default_exists;
--   if p_move_from_default and default_exists then
--     -- Move rows into the new partition safely (idempotent).
--     execute format(
--       'insert into uk_aq_core.observations
--        select * from uk_aq_core.observations_default
--        where connector_id = %L
--        on conflict do nothing',
--       p_connector_id
--     );
--     execute format(
--       'delete from uk_aq_core.observations_default where connector_id = %L',
--       p_connector_id
--     );
--   end if;
-- end;
-- $$;

-- =========================================================
-- [OPTIONAL] Recreate public views if needed (no signature changes)
-- =========================================================
-- set search_path = uk_aq_public, public;
-- create or replace view observations as
-- select timeseries_id, observed_at, value, status, created_at
-- from uk_aq_core.observations;
--
-- alter view if exists observations set (security_invoker = true);
