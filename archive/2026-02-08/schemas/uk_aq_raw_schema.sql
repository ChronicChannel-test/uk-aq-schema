-- uk_aq_raw schema (split from uk_air_quality_schema.sql)
create schema if not exists uk_aq_raw;
set search_path = uk_aq_raw, uk_aq_core, public;

create table if not exists uk_air_sos_site_register (
  id bigint generated by default as identity primary key,
  uk_air_id text not null,
  eu_site_id text,
  emep_site_id text,
  site_name text,
  environment_type text,
  zone text,
  start_date date,
  end_date date,
  latitude double precision,
  longitude double precision,
  northing double precision,
  easting double precision,
  altitude_m double precision,
  networks text[] not null default '{}'::text[],
  aurn_pollutants_measured text,
  site_description text,
  source_url text,
  source_file text,
  snapshot_at timestamptz not null default now(),
  raw_payload jsonb not null default '{}'::jsonb,
  created_at timestamptz default now()
);

create index if not exists uk_air_sos_site_register_uk_air_id_idx
  on uk_air_sos_site_register(uk_air_id);
create index if not exists uk_air_sos_site_register_snapshot_idx
  on uk_air_sos_site_register(snapshot_at);
create index if not exists uk_air_sos_site_register_networks_gin_idx
  on uk_air_sos_site_register using gin (networks);
create unique index if not exists uk_air_sos_site_register_snapshot_uidx
  on uk_air_sos_site_register(uk_air_id, snapshot_at);

create table if not exists laqn_site_register (
  id bigint generated by default as identity primary key,
  site_ref text not null,
  label text,
  station_name text,
  station_type text,
  station_exposure text,
  local_authority text,
  network_label text,
  networks text[] not null default '{}'::text[],
  latitude double precision,
  longitude double precision,
  lat_offset double precision,
  lon_offset double precision,
  site_url text,
  first_seen_at timestamptz,
  last_seen_at timestamptz,
  removed_at timestamptz,
  source_url text,
  source_file text,
  snapshot_at timestamptz not null default now(),
  raw_payload jsonb not null default '{}'::jsonb,
  created_at timestamptz default now()
);

create index if not exists laqn_site_register_site_ref_idx
  on laqn_site_register(site_ref);
create index if not exists laqn_site_register_snapshot_idx
  on laqn_site_register(snapshot_at);
create index if not exists laqn_site_register_networks_gin_idx
  on laqn_site_register using gin (networks);
create unique index if not exists laqn_site_register_snapshot_uidx
  on laqn_site_register(site_ref, snapshot_at);

create table if not exists uk_air_sos_station_refs (
  station_id bigint primary key references stations(id) on delete cascade,
  uk_air_id text not null,
  match_method text,
  match_distance_m double precision,
  source_snapshot_at timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create index if not exists uk_air_sos_station_refs_uk_air_id_idx
  on uk_air_sos_station_refs(uk_air_id);
create index if not exists uk_air_sos_station_refs_snapshot_idx
  on uk_air_sos_station_refs(source_snapshot_at);

create table if not exists breathelondon_timeseries_checkpoints (
  station_id bigint not null references stations(id) on delete cascade,
  species text not null,
  timeseries_id bigint references timeseries(id) on delete set null,
  last_observed_at timestamptz,
  last_polled_at timestamptz,
  last_error text,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  primary key (station_id, species)
);

create index if not exists breathelondon_timeseries_checkpoints_last_obs_idx
  on breathelondon_timeseries_checkpoints(last_observed_at);

create table if not exists breathelondon_station_checkpoints (
  station_id bigint primary key references stations(id) on delete cascade,
  next_due_at timestamptz,
  last_observed_at timestamptz,
  ingest_lag_samples int[] not null default '{}'::int[],
  last_polled_at timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create index if not exists breathelondon_station_checkpoints_next_due_at_idx
  on breathelondon_station_checkpoints(next_due_at);
create index if not exists breathelondon_station_checkpoints_last_polled_at_idx
  on breathelondon_station_checkpoints(last_polled_at);

create table if not exists erg_laqn_station_checkpoints (
  station_id bigint primary key references stations(id) on delete cascade,
  last_polled_at timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create index if not exists erg_laqn_station_checkpoints_last_polled_idx
  on erg_laqn_station_checkpoints(last_polled_at);

create table if not exists uk_air_sos_timeseries_checkpoints (
  timeseries_id bigint primary key references timeseries(id) on delete cascade,
  last_polled_at timestamptz not null,
  updated_at timestamptz not null default now()
);

create index if not exists uk_air_sos_timeseries_checkpoints_last_polled_at_idx
  on uk_air_sos_timeseries_checkpoints(last_polled_at);

create table if not exists openaq_station_checkpoints (
  station_id bigint primary key references stations(id) on delete cascade,
  next_due_at timestamptz,
  last_observed_at timestamptz,
  observ_interval_samples int[] not null default '{}'::int[],
  ingest_lag_samples int[] not null default '{}'::int[],
  last_polled_at timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now()
);

create index if not exists openaq_station_checkpoints_next_due_at_idx
  on openaq_station_checkpoints(next_due_at);
create index if not exists openaq_station_checkpoints_last_polled_at_idx
  on openaq_station_checkpoints(last_polled_at);

create table if not exists openaq_timeseries_checkpoints (
  station_id bigint not null references stations(id) on delete cascade,
  timeseries_id bigint not null references timeseries(id) on delete cascade,
  next_due_at timestamptz,
  last_observed_at timestamptz,
  ingest_lag_samples int[] not null default '{}'::int[],
  last_polled_at timestamptz,
  created_at timestamptz default now(),
  updated_at timestamptz default now(),
  primary key (station_id, timeseries_id)
);

create index if not exists openaq_timeseries_checkpoints_next_due_at_idx
  on openaq_timeseries_checkpoints(next_due_at);
create index if not exists openaq_timeseries_checkpoints_last_polled_at_idx
  on openaq_timeseries_checkpoints(last_polled_at);
create index if not exists openaq_timeseries_checkpoints_timeseries_id_idx
  on openaq_timeseries_checkpoints(timeseries_id);

create unique index if not exists stations_connector_ref_uidx
  on stations(connector_id, service_ref, station_ref);
create index if not exists stations_geom_idx on stations using gist (geometry);
create index if not exists stations_geom_cast_idx on stations using gist ((geometry::geometry));
create index if not exists stations_la_code_idx on stations(la_code);
create index if not exists stations_la_version_idx on stations(la_version);
create index if not exists stations_pcon_code_idx on stations(pcon_code);
create index if not exists stations_pcon_version_idx on stations(pcon_version);
create index if not exists stations_pcon_code_null_idx
  on stations(id)
  where pcon_code is null;

-- Local Authority boundaries (used to persist station LA codes)

create table if not exists error_logs (
  id uuid default gen_random_uuid() primary key,
  created_at timestamptz default now(),
  source text not null,
  severity text not null,
  message text not null,
  stack text,
  context jsonb,
  connector_id bigint references connectors(id) on delete set null,
  station_id bigint references stations(id) on delete set null,
  timeseries_id bigint references timeseries(id) on delete set null,
  dropbox_path text
);
create index if not exists error_logs_created_at_idx on error_logs(created_at desc);
create index if not exists error_logs_source_idx on error_logs(source);
create index if not exists error_logs_connector_idx on error_logs(connector_id);

-- PM2.5 Population Exposure Indicator progress (PERT)

-- Public RPCs for non-exposed schemas (service_role only)

create or replace function uk_aq_public.uk_aq_rpc_connector_select(connector_code text)
returns table (
  id bigint,
  connector_code text,
  label text,
  service_url text,
  overwrite_station_name boolean
)
language sql
security definer
set search_path = uk_aq_core, uk_aq_raw, public, pg_catalog
as $$
  select c.id, c.connector_code, c.label, c.service_url, c.overwrite_station_name
  from uk_aq_core.connectors c
  where c.connector_code = $1
  limit 1;
$$;

create or replace function uk_aq_public.uk_aq_rpc_station_names(
  connector_id bigint,
  service_ref text,
  station_refs text[]
)
returns table (
  station_ref text,
  station_name text
)
language sql
security definer
set search_path = uk_aq_core, uk_aq_raw, public, pg_catalog
as $$
  select s.station_ref, s.station_name
  from uk_aq_core.stations s
  where s.connector_id = $1
    and s.service_ref = $2
    and s.station_ref = any($3);
$$;

create or replace function uk_aq_public.uk_aq_rpc_station_ids(
  connector_id bigint,
  service_ref text,
  station_refs text[]
)
returns table (
  station_ref text,
  id bigint
)
language sql
security definer
set search_path = uk_aq_core, uk_aq_raw, public, pg_catalog
as $$
  select s.station_ref, s.id
  from uk_aq_core.stations s
  where s.connector_id = $1
    and s.service_ref = $2
    and s.station_ref = any($3);
$$;

create or replace function uk_aq_public.uk_aq_rpc_openaq_station_checkpoints_select(
  station_ids bigint[]
)
returns table (
  station_id bigint,
  next_due_at timestamptz,
  last_observed_at timestamptz,
  observ_interval_samples int[],
  ingest_lag_samples int[],
  last_polled_at timestamptz
)
language sql
security definer
set search_path = uk_aq_raw, public, pg_catalog
as $$
  select
    station_id,
    next_due_at,
    last_observed_at,
    observ_interval_samples,
    ingest_lag_samples,
    last_polled_at
  from uk_aq_raw.openaq_station_checkpoints
  where station_id = any($1);
$$;

create or replace function uk_aq_public.uk_aq_rpc_openaq_station_checkpoints_upsert(rows jsonb)
returns table (rows_upserted int)
language plpgsql
security definer
set search_path = uk_aq_raw, public, pg_catalog
as $$
declare
  count_rows int := 0;
begin
  if rows is null or jsonb_typeof(rows) <> 'array' or jsonb_array_length(rows) = 0 then
    return query select 0;
    return;
  end if;
  insert into uk_aq_raw.openaq_station_checkpoints (
    station_id,
    next_due_at,
    last_observed_at,
    observ_interval_samples,
    ingest_lag_samples,
    last_polled_at
  )
  select
    r.station_id,
    r.next_due_at,
    r.last_observed_at,
    r.observ_interval_samples,
    r.ingest_lag_samples,
    r.last_polled_at
  from jsonb_to_recordset(rows) as r(
    station_id bigint,
    next_due_at timestamptz,
    last_observed_at timestamptz,
    observ_interval_samples int[],
    ingest_lag_samples int[],
    last_polled_at timestamptz
  )
  on conflict (station_id) do update set
    next_due_at = excluded.next_due_at,
    last_observed_at = excluded.last_observed_at,
    observ_interval_samples = excluded.observ_interval_samples,
    ingest_lag_samples = excluded.ingest_lag_samples,
    last_polled_at = excluded.last_polled_at,
    updated_at = now();
  get diagnostics count_rows = row_count;
  return query select count_rows;
end;
$$;

create or replace function uk_aq_public.uk_aq_rpc_openaq_timeseries_checkpoints_select(
  station_ids bigint[]
)
returns table (
  station_id bigint,
  timeseries_id bigint,
  next_due_at timestamptz,
  last_observed_at timestamptz,
  ingest_lag_samples int[],
  last_polled_at timestamptz
)
language sql
security definer
set search_path = uk_aq_raw, public, pg_catalog
as $$
  select
    station_id,
    timeseries_id,
    next_due_at,
    last_observed_at,
    ingest_lag_samples,
    last_polled_at
  from uk_aq_raw.openaq_timeseries_checkpoints
  where station_id = any($1);
$$;

create or replace function uk_aq_public.uk_aq_rpc_openaq_timeseries_checkpoints_upsert(rows jsonb)
returns table (rows_upserted int)
language plpgsql
security definer
set search_path = uk_aq_raw, public, pg_catalog
as $$
declare
  count_rows int := 0;
begin
  if rows is null or jsonb_typeof(rows) <> 'array' or jsonb_array_length(rows) = 0 then
    return query select 0;
    return;
  end if;
  insert into uk_aq_raw.openaq_timeseries_checkpoints (
    station_id,
    timeseries_id,
    next_due_at,
    last_observed_at,
    ingest_lag_samples,
    last_polled_at
  )
  select
    r.station_id,
    r.timeseries_id,
    r.next_due_at,
    r.last_observed_at,
    r.ingest_lag_samples,
    r.last_polled_at
  from jsonb_to_recordset(rows) as r(
    station_id bigint,
    timeseries_id bigint,
    next_due_at timestamptz,
    last_observed_at timestamptz,
    ingest_lag_samples int[],
    last_polled_at timestamptz
  )
  on conflict (station_id, timeseries_id) do update set
    next_due_at = excluded.next_due_at,
    last_observed_at = excluded.last_observed_at,
    ingest_lag_samples = excluded.ingest_lag_samples,
    last_polled_at = excluded.last_polled_at,
    updated_at = now();
  get diagnostics count_rows = row_count;
  return query select count_rows;
end;
$$;

create or replace function uk_aq_public.uk_aq_rpc_openaq_select_station_refs(
  batch_limit integer default 50,
  stale_limit integer default 10
)
returns table (
  station_ref text,
  station_id bigint
)
language plpgsql
security definer
set search_path = uk_aq_core, uk_aq_raw, public, pg_catalog
as $$
declare
  v_connector_id bigint;
begin
  select id into v_connector_id
  from uk_aq_core.connectors
  where connector_code = 'openaq'
  limit 1;

  if v_connector_id is null then
    return;
  end if;

  return query
  with latest_obs as (
    select
      t.station_id,
      max(t.last_value_at) as last_observed_at
    from uk_aq_core.timeseries t
    where t.connector_id = v_connector_id
      and t.service_ref = 'openaq'
    group by t.station_id
  ),
  candidates as (
    select
      stn.id as station_id,
      stn.station_ref as station_ref,
      osc.next_due_at,
      osc.last_polled_at,
      coalesce(osc.last_observed_at, lo.last_observed_at) as last_observed_at,
      coalesce(osc.next_due_at, now()) as due_at
    from uk_aq_core.stations stn
    left join uk_aq_raw.openaq_station_checkpoints osc
      on osc.station_id = stn.id
    left join latest_obs lo
      on lo.station_id = stn.id
    where stn.connector_id = v_connector_id
      and stn.service_ref = 'openaq'
      and stn.station_ref is not null
      and stn.removed_at is null
  ),
  tiered as (
    select
      c.station_id,
      c.station_ref,
      c.due_at,
      c.last_polled_at
    from candidates c
    where c.due_at <= now()
      and c.due_at >= now() - interval '3 hours'
      and (c.last_polled_at is null or c.last_polled_at <= now() - interval '5 minutes')
    union all
    select
      c.station_id,
      c.station_ref,
      c.due_at,
      c.last_polled_at
    from candidates c
    where c.due_at < now() - interval '3 hours'
      and c.due_at >= now() - interval '24 hours'
      and (c.last_polled_at is null or c.last_polled_at <= now() - interval '1 hour')
  ),
  tiered_limited as (
    select *
    from tiered
    order by last_polled_at asc nulls first, due_at asc
    limit batch_limit
  ),
  stale as (
    select
      c.station_id,
      c.station_ref,
      c.last_observed_at
    from candidates c
    where (c.last_observed_at is null or c.last_observed_at <= now() - interval '24 hours')
      and (c.last_polled_at is null or c.last_polled_at <= now() - interval '12 hours')
      and not exists (
        select 1 from tiered_limited t where t.station_id = c.station_id
      )
    order by c.last_observed_at nulls first
    limit stale_limit
  ),
  combined as (
    select tl.station_ref, tl.station_id, 1 as group_order, tl.due_at as sort_at
    from tiered_limited tl
    union all
    select s.station_ref, s.station_id, 2 as group_order, null as sort_at
    from stale s
  )
  select combined.station_ref, combined.station_id
  from combined
  order by combined.group_order, combined.sort_at nulls last;
end;
$$;

create or replace function uk_aq_public.uk_aq_rpc_dispatch_claim(
  p_connector_code text,
  p_run_started_at timestamptz,
  p_timeout_minutes integer default 10
)
returns table (
  claimed boolean,
  connector_id bigint,
  last_run_start timestamptz,
  last_run_end timestamptz
)
language plpgsql
security definer
set search_path = uk_aq_core, uk_aq_raw, public, pg_catalog
as $$
declare
  v_timeout interval;
begin
  if auth.role() <> 'service_role' then
    raise exception 'service_role required';
  end if;

  v_timeout := make_interval(mins => greatest(1, coalesce(p_timeout_minutes, 10)));

  return query
  with updated as (
    update uk_aq_core.connectors c
    set
      last_run_start = p_run_started_at,
      last_run_end = null,
      last_run_status = 'running',
      last_run_message = 'dispatching'
    where c.connector_code = p_connector_code
      and (
        c.last_run_end is not null
        or c.last_run_start is null
        or c.last_run_start <= now() - v_timeout
      )
    returning c.id, c.last_run_start, c.last_run_end
  )
  select
    (count(*) > 0) as claimed,
    max(updated.id) as connector_id,
    max(updated.last_run_start) as last_run_start,
    max(updated.last_run_end) as last_run_end
  from updated;
end;
$$;

create or replace function uk_aq_public.uk_aq_rpc_stations_upsert(rows jsonb)
returns table (stations_upserted int)
language plpgsql
security definer
set search_path = uk_aq_core, uk_aq_raw, public, pg_catalog
as $$
declare
  count_rows int := 0;
begin
  if rows is null or jsonb_typeof(rows) <> 'array' or jsonb_array_length(rows) = 0 then
    return query select 0;
    return;
  end if;
  insert into uk_aq_core.stations (
    station_ref,
    service_ref,
    label,
    station_name,
    station_type,
    region,
    geometry,
    connector_id,
    last_seen_at,
    removed_at
  )
  select
    r.station_ref,
    r.service_ref,
    r.label,
    r.station_name,
    r.station_type,
    r.region,
    case
      when r.geometry is null or r.geometry = '' then null
      else ST_GeogFromText(r.geometry)
    end,
    r.connector_id,
    r.last_seen_at,
    r.removed_at
  from jsonb_to_recordset(rows) as r(
    station_ref text,
    service_ref text,
    label text,
    station_name text,
    station_type text,
    region text,
    geometry text,
    connector_id bigint,
    last_seen_at timestamptz,
    removed_at timestamptz
  )
  on conflict (connector_id, service_ref, station_ref) do update set
    label = excluded.label,
    station_name = excluded.station_name,
    station_type = excluded.station_type,
    region = excluded.region,
    geometry = excluded.geometry,
    last_seen_at = excluded.last_seen_at,
    removed_at = excluded.removed_at;
  get diagnostics count_rows = row_count;
  return query select count_rows;
end;
$$;

create or replace function uk_aq_public.uk_aq_rpc_station_metadata_upsert(rows jsonb)
returns table (station_metadata_upserted int)
language plpgsql
security definer
set search_path = uk_aq_core, uk_aq_raw, public, pg_catalog
as $$
declare
  count_rows int := 0;
begin
  if rows is null or jsonb_typeof(rows) <> 'array' or jsonb_array_length(rows) = 0 then
    return query select 0;
    return;
  end if;
  insert into uk_aq_core.station_metadata (
    station_id,
    attributes,
    updated_at
  )
  select
    r.station_id,
    coalesce(r.attributes, '{}'::jsonb),
    coalesce(r.updated_at, now())
  from jsonb_to_recordset(rows) as r(
    station_id bigint,
    attributes jsonb,
    updated_at timestamptz
  )
  on conflict (station_id) do update set
    attributes = uk_aq_core.station_metadata.attributes || excluded.attributes,
    updated_at = excluded.updated_at;
  get diagnostics count_rows = row_count;
  return query select count_rows;
end;
$$;

create or replace function uk_aq_public.uk_aq_rpc_phenomena_upsert(rows jsonb)
returns table (phenomena_upserted int)
language plpgsql
security definer
set search_path = uk_aq_core, uk_aq_raw, public, pg_catalog
as $$
declare
  count_rows int := 0;
begin
  if rows is null or jsonb_typeof(rows) <> 'array' or jsonb_array_length(rows) = 0 then
    return query select 0;
    return;
  end if;
  insert into uk_aq_core.phenomena (
    connector_id,
    eionet_uri,
    label,
    notation,
    pollutant_label
  )
  select
    r.connector_id,
    r.eionet_uri,
    r.label,
    r.notation,
    r.pollutant_label
  from jsonb_to_recordset(rows) as r(
    connector_id bigint,
    eionet_uri text,
    label text,
    notation text,
    pollutant_label text
  )
  on conflict (connector_id, eionet_uri) do update set
    label = excluded.label,
    notation = excluded.notation,
    pollutant_label = excluded.pollutant_label;
  get diagnostics count_rows = row_count;
  return query select count_rows;
end;
$$;

create or replace function uk_aq_public.uk_aq_rpc_phenomena_ids(
  connector_id bigint,
  eionet_uris text[]
)
returns table (
  eionet_uri text,
  id bigint
)
language sql
security definer
set search_path = uk_aq_core, uk_aq_raw, public, pg_catalog
as $$
  select p.eionet_uri, p.id
  from uk_aq_core.phenomena p
  where p.connector_id = $1
    and p.eionet_uri = any($2);
$$;

create or replace function uk_aq_public.uk_aq_rpc_timeseries_upsert(rows jsonb)
returns table (timeseries_upserted int)
language plpgsql
security definer
set search_path = uk_aq_core, uk_aq_raw, public, pg_catalog
as $$
declare
  count_rows int := 0;
begin
  if rows is null or jsonb_typeof(rows) <> 'array' or jsonb_array_length(rows) = 0 then
    return query select 0;
    return;
  end if;
  insert into uk_aq_core.timeseries (
    timeseries_ref,
    label,
    uom,
    station_id,
    connector_id,
    service_ref,
    phenomenon_id
  )
  select
    r.timeseries_ref,
    r.label,
    r.uom,
    r.station_id,
    r.connector_id,
    r.service_ref,
    r.phenomenon_id
  from jsonb_to_recordset(rows) as r(
    timeseries_ref text,
    label text,
    uom text,
    station_id bigint,
    connector_id bigint,
    service_ref text,
    phenomenon_id bigint
  )
  on conflict (connector_id, service_ref, timeseries_ref) do update set
    label = excluded.label,
    uom = excluded.uom,
    station_id = excluded.station_id,
    phenomenon_id = excluded.phenomenon_id;
  get diagnostics count_rows = row_count;
  return query select count_rows;
end;
$$;

create or replace function uk_aq_public.uk_aq_rpc_timeseries_ids(
  connector_id bigint,
  service_ref text,
  timeseries_refs text[]
)
returns table (
  timeseries_ref text,
  id bigint
)
language sql
security definer
set search_path = uk_aq_core, uk_aq_raw, public, pg_catalog
as $$
  select t.timeseries_ref, t.id
  from uk_aq_core.timeseries t
  where t.connector_id = $1
    and t.service_ref = $2
    and t.timeseries_ref = any($3);
$$;

create or replace function uk_aq_public.uk_aq_rpc_timeseries_refs_by_station_ids(
  connector_id bigint,
  service_ref text,
  station_ids bigint[]
)
returns table (
  station_id bigint,
  timeseries_id bigint,
  timeseries_ref text
)
language sql
security definer
set search_path = uk_aq_core, uk_aq_raw, public, pg_catalog
as $$
  select t.station_id, t.id as timeseries_id, t.timeseries_ref
  from uk_aq_core.timeseries t
  where t.connector_id = $1
    and t.service_ref = $2
    and t.station_id = any($3);
$$;

create or replace function uk_aq_public.uk_aq_rpc_observations_upsert(rows jsonb)
returns table (observations_upserted int)
language plpgsql
security definer
set search_path = uk_aq_core, uk_aq_raw, public, pg_catalog
as $$
declare
  count_rows int := 0;
begin
  if rows is null or jsonb_typeof(rows) <> 'array' or jsonb_array_length(rows) = 0 then
    return query select 0;
    return;
  end if;
  insert into uk_aq_core.observations (
    connector_id,
    timeseries_id,
    observed_at,
    value,
    status
  )
  select
    r.connector_id,
    r.timeseries_id,
    r.observed_at,
    r.value,
    r.status
  from jsonb_to_recordset(rows) as r(
    connector_id bigint,
    timeseries_id bigint,
    observed_at timestamptz,
    value numeric,
    status text
  )
  on conflict (connector_id, timeseries_id, observed_at) do update set
    value = excluded.value,
    status = excluded.status;
  get diagnostics count_rows = row_count;
  return query select count_rows;
end;
$$;

create or replace function uk_aq_public.uk_aq_rpc_timeseries_last_values_update(rows jsonb)
returns table (timeseries_updated int)
language plpgsql
security definer
set search_path = uk_aq_core, uk_aq_raw, public, pg_catalog
as $$
declare
  count_rows int := 0;
begin
  if rows is null or jsonb_typeof(rows) <> 'array' or jsonb_array_length(rows) = 0 then
    return query select 0;
    return;
  end if;
  with updates as (
    select * from jsonb_to_recordset(rows) as r(
      id bigint,
      last_value numeric,
      last_value_at timestamptz
    )
  )
  update uk_aq_core.timeseries t
  set last_value = u.last_value,
      last_value_at = u.last_value_at
  from updates u
  where t.id = u.id;
  get diagnostics count_rows = row_count;
  return query select count_rows;
end;
$$;

create or replace function uk_aq_public.uk_aq_rpc_error_log_insert(entry jsonb)
returns table (id uuid)
language plpgsql
security definer
set search_path = uk_aq_raw, uk_aq_core, public, pg_catalog
as $$
declare
  new_id uuid;
begin
  insert into uk_aq_raw.error_logs (
    source,
    severity,
    message,
    stack,
    context,
    connector_id,
    station_id,
    timeseries_id,
    dropbox_path
  )
  values (
    coalesce(entry->>'source', 'unknown'),
    coalesce(entry->>'severity', 'error'),
    coalesce(entry->>'message', 'unknown'),
    entry->>'stack',
    entry->'context',
    nullif(entry->>'connector_id', '')::bigint,
    nullif(entry->>'station_id', '')::bigint,
    nullif(entry->>'timeseries_id', '')::bigint,
    entry->>'dropbox_path'
  )
  returning uk_aq_raw.error_logs.id into new_id;
  return query select new_id;
end;
$$;

revoke all on function uk_aq_public.uk_aq_rpc_connector_select(text) from public;
grant execute on function uk_aq_public.uk_aq_rpc_connector_select(text) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_station_names(bigint, text, text[]) from public;
grant execute on function uk_aq_public.uk_aq_rpc_station_names(bigint, text, text[]) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_station_ids(bigint, text, text[]) from public;
grant execute on function uk_aq_public.uk_aq_rpc_station_ids(bigint, text, text[]) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_openaq_station_checkpoints_select(bigint[]) from public;
grant execute on function uk_aq_public.uk_aq_rpc_openaq_station_checkpoints_select(bigint[]) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_openaq_station_checkpoints_upsert(jsonb) from public;
grant execute on function uk_aq_public.uk_aq_rpc_openaq_station_checkpoints_upsert(jsonb) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_openaq_timeseries_checkpoints_select(bigint[]) from public;
grant execute on function uk_aq_public.uk_aq_rpc_openaq_timeseries_checkpoints_select(bigint[]) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_openaq_timeseries_checkpoints_upsert(jsonb) from public;
grant execute on function uk_aq_public.uk_aq_rpc_openaq_timeseries_checkpoints_upsert(jsonb) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_openaq_select_station_refs(integer, integer) from public;
grant execute on function uk_aq_public.uk_aq_rpc_openaq_select_station_refs(integer, integer) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_dispatch_claim(text, timestamptz, integer) from public;
grant execute on function uk_aq_public.uk_aq_rpc_dispatch_claim(text, timestamptz, integer) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_stations_upsert(jsonb) from public;
grant execute on function uk_aq_public.uk_aq_rpc_stations_upsert(jsonb) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_station_metadata_upsert(jsonb) from public;
grant execute on function uk_aq_public.uk_aq_rpc_station_metadata_upsert(jsonb) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_phenomena_upsert(jsonb) from public;
grant execute on function uk_aq_public.uk_aq_rpc_phenomena_upsert(jsonb) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_phenomena_ids(bigint, text[]) from public;
grant execute on function uk_aq_public.uk_aq_rpc_phenomena_ids(bigint, text[]) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_timeseries_upsert(jsonb) from public;
grant execute on function uk_aq_public.uk_aq_rpc_timeseries_upsert(jsonb) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_timeseries_ids(bigint, text, text[]) from public;
grant execute on function uk_aq_public.uk_aq_rpc_timeseries_ids(bigint, text, text[]) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_timeseries_refs_by_station_ids(
  bigint,
  text,
  bigint[]
) from public;
grant execute on function uk_aq_public.uk_aq_rpc_timeseries_refs_by_station_ids(
  bigint,
  text,
  bigint[]
) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_observations_upsert(jsonb) from public;
grant execute on function uk_aq_public.uk_aq_rpc_observations_upsert(jsonb) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_timeseries_last_values_update(jsonb) from public;
grant execute on function uk_aq_public.uk_aq_rpc_timeseries_last_values_update(jsonb) to service_role;

revoke all on function uk_aq_public.uk_aq_rpc_error_log_insert(jsonb) from public;
grant execute on function uk_aq_public.uk_aq_rpc_error_log_insert(jsonb) to service_role;
